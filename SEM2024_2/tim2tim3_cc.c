#include <main.h>
#include <stdio.h>

//generates a signal with TIM3
//measures frequency with TIM2


TIM_HandleTypeDef htim3 = {0};
TIM_HandleTypeDef htim2 = {0};

UART_HandleTypeDef huart2 = {0};

uint16_t first_time = 1;
uint16_t printif = 0;

float dif_time, freq;

uint8_t buflen, buffer[32];

int main(void)
{
	HAL_Init();
	GPIO_Init();
	TIM3_Init(); //generar senial
	TIM2_Init(); //medir senial
	UART2_Init();

	while(1)
	{
		HAL_Delay(50);
		if(printif)
		{
			buflen = sprintf((char*)buffer, "Frequency: %f\r\n", freq);
			HAL_UART_Transmit(&huart2, buffer, buflen, HAL_MAX_DELAY);
			HAL_Delay(50);
			printif=0;
		}



	}

	return 0;
}


//captures the time difference between consecutive rising edges of the
//signal generated by TIM3, allowing the frequency of the signal to be calculated

//callback function for TIM2 input capture, its called whenever a rising edge is detected
//on the input pin connected to TIM2
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
	static uint32_t value, pre_value = 0;
	uint16_t dif_value;
	//float dif_time, freq;

	if(htim -> Instance == TIM2)
	{
		//si es la segunda vez que se llama, entonces calcular la diferencia de tiempo entre flanco y flanco de subida generado por el timer3
		if(first_time)
		{
			pre_value = __HAL_TIM_GET_COUNTER(&htim2);
			first_time = 0;
		}
		//si no, guarda el tiempo del flanco, siendo este el primero que registra el timer 2
		else
		{
			value = __HAL_TIM_GET_COUNTER(&htim2);
			dif_value = value - pre_value;
			dif_time = dif_value * 0.000001;
			if(dif_time != 0.0)
			{
				freq = 1 / dif_time;
				printif = 1;
			}
			else
			{
				freq = 0.0;
			}

			pre_value = value;

		}


	}
}


void TIM2_IRQHandler(void)
{
	HAL_TIM_IRQHandler(&htim2);
}


//el timer 2 se va a encargar de medir entre flanco y flanco de subida de la senal de 2 hz generada por el timer 3
void TIM2_Init(void)
{
	//1. Habilitar reloj para periferico
	__HAL_RCC_TIM2_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();
	//2. Configuracion de bajo nivel (pins que va a utilizar)

	//pin de captura de entrada

	//configures the input capture pin PA0 for TIM2 with pull down resistor
	GPIO_InitTypeDef ic_pin = {0};
	ic_pin.Pin = GPIO_PIN_0;
	ic_pin.Mode = GPIO_MODE_AF_PP;
	ic_pin.Alternate = GPIO_AF1_TIM2;
	ic_pin.Pull = GPIO_PULLDOWN;
	HAL_GPIO_Init(GPIOA, &ic_pin);

	//3.Habilitacion de la interrupcion
	HAL_NVIC_SetPriority(TIM2_IRQn, 15, 0); //NESTED VECTOR INTERRUPT CONTROLLER
	HAL_NVIC_EnableIRQ(TIM2_IRQn); //interrupcion a traves del canal 3
	//4. Configuracion de alto nivel
	htim2.Instance = TIM2; //miembro que va a asociar a que timer va
	//CK_CNT = CK_PSC // (1 + Prescaler)
	htim2.Init.Prescaler = 15; //16M/16=1M FRQ= 1us

	////UI_Freq = CK_CNT //(1 + Period)
	//htim3.Init.Period = 250; //hasta donde llega el contador antes de desbordarse

	htim2.Init.Period = 0xFFFFFFFF; //contador de carrera libre
	//UI_Freq = CLK_PSC / (Prescaler * Period)
	//cargarle al timer la configuracion
	if(HAL_TIM_IC_Init(&htim2) != HAL_OK)
		{
			Error_Handler();
		}

	TIM_IC_InitTypeDef ic_channel = {0};
	ic_channel.ICSelection = TIM_ICSELECTION_DIRECTTI;
	ic_channel.ICPolarity = TIM_ICPOLARITY_RISING;
	if(HAL_TIM_IC_ConfigChannel(&htim2, &ic_channel, TIM_CHANNEL_1) != HAL_OK)
	{
		Error_Handler();
	}

	//5. Arrancar el periferico
	HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_1); //Apuntador al periferico

}

void TIM3_Init(void)
{
	//1. Habilitar reloj para periferico
	__HAL_RCC_TIM3_CLK_ENABLE();
	__HAL_RCC_GPIOB_CLK_ENABLE();
	//2. Configuracion de bajo nivel (pins que va a utilizar)

	GPIO_InitTypeDef oc_pin = {0};
	oc_pin.Pin = GPIO_PIN_4;
	oc_pin.Mode = GPIO_MODE_AF_PP;
	oc_pin.Alternate = GPIO_AF2_TIM3;
	HAL_GPIO_Init(GPIOB, &oc_pin);

	//3.Habilitacion de la interrupcion
	//HAL_NVIC_SetPriority(TIM3_IRQn, 15, 0); //NESTED VECTOR INTERRUPT CONTROLLER
	//HAL_NVIC_EnableIRQ(TIM3_IRQn); //interrupcion a traves del canal 3
	//4. Configuracion de alto nivel
	htim3.Instance = TIM3; //miembro que va a asociar a que timer va
	//CK_CNT = CK_PSC // (1 + Prescaler)

	//every 4kHz or 250us
	htim3.Init.Prescaler = 3;

	////UI_Freq = CK_CNT //(1 + Period)
	//htim3.Init.Period = 250; //hasta donde llega el contador antes de desbordarse

	htim3.Init.Period = 999;
	//UI_Freq = CLK_PSC / (Prescaler * Period)
	//cargarle al timer la configuracion
	if(HAL_TIM_OC_Init(&htim3) != HAL_OK)
		{
			Error_Handler();
		}

	TIM_OC_InitTypeDef oc_channel = {0};
	oc_channel.OCMode = TIM_OCMODE_TOGGLE; //TAREA PROBAR DIF MODOS OCMODE PWM...
	oc_channel.Pulse = 500;
	oc_channel.OCNPolarity = TIM_OCPOLARITY_HIGH;
	if(HAL_TIM_OC_ConfigChannel(&htim3, &oc_channel, TIM_CHANNEL_1) != HAL_OK)
	{
		Error_Handler();
	}


	//5. Arrancar el periferico
	HAL_TIM_OC_Start(&htim3, TIM_CHANNEL_1); //Apuntador al periferico

}

void GPIO_Init(void)
{
	GPIO_InitTypeDef led_pin = {0};
	led_pin.Pin = GPIO_PIN_5;
	led_pin.Mode = GPIO_MODE_OUTPUT_PP;
	__HAL_RCC_GPIOA_CLK_ENABLE();
	HAL_GPIO_Init(GPIOA, &led_pin);
}


void UART2_Init(void)
{
	/* Habilitar seÃ±ales de reloj */
	__HAL_RCC_USART2_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();

	/* 2. Configuracion de bajo nivel */
	GPIO_InitTypeDef tx_pin = {0};
	tx_pin.Pin = GPIO_PIN_2 | GPIO_PIN_3;
	tx_pin.Mode = GPIO_MODE_AF_PP;
	tx_pin.Alternate = GPIO_AF7_USART2;
	HAL_GPIO_Init(GPIOA, &tx_pin);
	/* 3. Habilitar interrupcion */
	HAL_NVIC_SetPriority(USART2_IRQn, 15, 0);
	HAL_NVIC_EnableIRQ(USART2_IRQn);

	/* 4. Configuracion de alto nivel */
	huart2.Instance = USART2;
	huart2.Init.BaudRate = 115200;
	huart2.Init.Mode = UART_MODE_TX_RX;
	if (HAL_UART_Init(&huart2) != HAL_OK)
		Error_Handler();
	// 5. Iniciar el periférico (todos aquellos que comienzan a trabajar y generan algun tipo de resultado)

}




void SysTick_Handler(void)
{
	HAL_IncTick();
	HAL_SYSTICK_IRQHandler();
}

void Error_Handler()
{
	while(1)
	{
		HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
		HAL_Delay(50);
	}
}
